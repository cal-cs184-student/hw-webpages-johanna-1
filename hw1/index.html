<html>
	<head>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=default'></script>
		<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
		<style>
			h1 {
				text-align: center;
			}

			.container {
				margin: 0 auto;
				padding: 60px 20%;
			}

			figure {
				text-align: center;
			}

			img {
				display: inline-block;
			}

			body {
				font-family: 'Inter', sans-serif;
			}
		</style>
	</head>
	<body>
		<div class="container">
		<h1>CS184/284A Spring 2025 Homework 1 Write-Up</h1>
		<div style="text-align: center;">Names: Johanna Liu </div>

		<br>

		Link to webpage: <a href="https://cal-cs184-student.github.io/hw-webpages-johanna-1/hw1/index.html">cal-cs184-student.github.io/hw-webpages-johanna-1/hw1/index.html</a>
		
		<br>

		Link to GitHub repository: <a href="https://github.com/cal-cs184-student/hw1-rasterizer-johanna">github.com/cal-cs184-student/hw1-rasterizer-johanna</a>
<!--
		<figure>
			<img src="lion.jpg" alt="Lion" style="width:50%"/>
			<figcaption>You can add images with captions!</figcaption>
		</figure>
			-->

		<!--
		We've already added one heading per task, to make your write-up as navigable when grading. Please fit your write-up within these sections!
		-->

		<h2>Overview</h2>
		- Give a high-level overview of what you implemented in this homework. Think about what you've built as a whole. Share your thoughts on what interesting things you've learned from completing the homework.
			<br><br>
			We implemented functions that rasterized triangles in order to present graphics on a screen. We started with simple implementations of rasterizing triangles
			then continued with supersampling to get rid of jaggies. Then we worked on transforms of shapes. We moved on to dealing with textures, implementing colors for 
			our triangles, using pixel sampling for texture mapping. The barycentric coordinate system was important for interpolation. We investigated how different sampling methods both on a pixel and level basis 
			would impact how our graphics turn out. 

		<h2>Task 1: Drawing Single-Color Triangles</h2>
		- Walk through how you rasterize triangles in your own words.<br>
			The function rasterize_triangles takes in parameters of three points and a color. Firstly, we check every pixel in our bounds --
			note that here we use the center of the pixel as sample points for each pixel. A triangle consists of three vertices/points, and 
			let's represent these points with the parameters given: <br>
			A = (x0, y0)<br>
			B = (x1, y1)<br>
			C = (x2, y2)<br>
			I want to test a point P = (px, py) for whether it is in the triangle and is to be colored.<br>
			I compute the 2D crossproduct of a triangle edge (say, AB,) and a vertex (say, A) to the unknown point P, simply using the common equation.
			Calculating the cross products then tells me which side of AB (or whichever edge) P is on. If the cross product is >0, P is on one side, if <0,
			P is on the other side. If =0, P is on the line. If P is on the SAME side of all AB, BC, and CA, then it is inside the triangle. 
			This takes into account both clockwise and counter-clockwise vertex winding.<br>  
			<br>
		- Explain how your algorithm is no worse than one that checks each sample within the bounding box of the triangle. <br>
<br>
			My xmin, xmax is the horizontal range that I must check (using given vertices of the triangle), and my ymin, ymax is my vertical range that I must check. 
			This just is the bounding box of the triangle. I am checking within that rectangle, so it is of course, not worse. <br>
<br>
		- Show a png screenshot of basic/test4.svg with the default viewing parameters and with the pixel inspector centered on an interesting part of the scene.<br>
				<img src="screenshot_2-17_22-5-50.png" alt="test4" style="width:50%"/><br>
<br>
		- Extra credit<br>
		    I doubt this counts, but I did OpenGL edge rules before I realized that it is not necessary. I hashed it out and rewrote the simpler version, so the code is still there.
			(Though I also hashed a large part of that out, too, after doing Task 2.) 
			
			
			

<!--		<p>Here is an example 2x2 gridlike structure using an HTML table. Each <b>tr</b> is a row and each <b>td</b> is a column in that row. You might find this useful for framing and showing your result images in an organized fashion.</p>
				-->
		
		
		<h2>Task 2: Antialiasing by Supersampling</h2>
		- Walk through your supersampling algorithm and data structures.<br> 
				Why is supersampling useful? 
				What modifications did you make to the rasterization pipeline in the process?

			The rasterization pipeline is like this:
			Triangles (rasterize triangle) are drawn into the sample_buffer, and resolve_to_framebuffer converts that into rgb_framebuffer_target.

			Modifications I made are:<br>
				In <b>rasterize_triangle</b>, I had to take into account the super sampled pixels, ie a sample rate of 4 now giving each pixel 2x2 grid.<br>
				So aside from iterating over the bounding box, I also iterated every pixel individually using the sqrt of the sample rate,
				splitting what used to be the center of the pixel sample points into however many sample points now required for the different sample rates.
				The sample_buffer then used the calculated index (that takes into account supersampling) to fill in the sub-pixels with colors.
			<br><br>
				Next, I modified <b>fill_pixel()</b> with a similar logic. It should iterate over the supersampled sub-pixels, too, with sample_buffer once 
				again using a modified index. 
				In <b>set_sample_rate()</b> and <b>set_framebuffer_target()</b>, I just made sure that sample_buffer was resized with (width * height * sample_rate)
				instead of only (width * height) since, once again, this modification is needed for the extra grid within each pixel. 
				In <b>resolve_to_framebuffer()</b>, we modified it from the original by averaging out all sub-pixels (instead of only able to read on pixel/sub-pixel)
				
			<br><br>
				Supersampling is useful because it "smooths" out edges with gradiented colors by sampling more color data within each pixel. This removes
				jaggies, and just overall increases the quality of graphics. 

			<br><br>
		- Show png screenshots of basic/test4.svg with the default viewing parameters and sample rates 1, 4, and 16 to compare them side-by-side.
	<br><br>
				<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="screenshot_2-17_22-54-16.png" width="400px"/>
				  <figcaption>Sample rate of 1.</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="screenshot_2-17_22-54-27.png" width="400px"/>
				  <figcaption>Sample rate of 4.</figcaption>
				</td>
				  <td style="text-align: center;">
				  <img src="screenshot_2-17_22-54-35.png" width="400px"/>
				  <figcaption>Sample rate of 16.</figcaption>
				</td>
			  </tr>
			  
			</table>
		</div>


	

		<h2>Task 3: Transforms</h2><br>
		<img src="task3.png" alt="just a guy" style="width:50%"/>
		<figcaption>He's trying to pour the water out of his head!!!</figcaption>
				
				<br><br>
				

		<h2>Task 4: Barycentric coordinates</h2>
				<br>
		- Explain barycentric coordinates in your own words and use an image to aid you in your explanation.<br>
				<br>
				Given any point P=(x,y) inside a triangle, it can be written as P = αA + βB + γC 
				(using the same A B C for each vertex notation from earlier).<br>
				And α + β + γ = 1.<br>
				The pixel is inside the triangle if all three coordinates are non-negative.<br>
				Barycentric coordinates are weights for each vertex at a pixel, aka they tell you
				how much each vertex contributes to the pixel (how much each pixel "belong" to a vertex). 
				Using these coordinates, the cross product uv in our code
				represents the texture coordinate for that pixel. A weighted sum of each vertex's color.
				For example, a pixel near the center of triangle would have a more blended color.
<br><br>
				<img src="TRIANGLESS.png" alt="triangle" style="width:50%"/>
		<figcaption>A visual representation using a triangle.</figcaption>
				

				<br><br>
		- Show a png screenshot of svg/basic/test7.svg<br>
				<br>
				<img src="task4.png" alt="task4" style="width:50%"/>
			<figcaption>The color wheel</figcaption>
				<br><br>
				
		<h2>Task 5: "Pixel sampling" for texture mapping</h2>
				<br><br>
		- Explain pixel sampling in your own words and describe how you implemented it to perform texture mapping. 
				Briefly discuss the two different pixel sampling methods, nearest and bilinear.
				<br><br>
				Pixel sampling is just turning a given coordinate (u,v) into a color (or a texture).
		Applying textures is sampling, so texture mapping uses pixel sampling to applying texture (2D) to a graphic on our screen.
		Since we only know the UV at the triangle vertices, we used barycentric coordinates to determine locations (UVs) of the pixels inside 
				these triangles. So we're using barycentric coordinates to "interpolate" these locations to fill with color/texture.<br><br>
				Nearest and bilinear: <br>
				For nearest, we just pick the texel that is closest to the center of the pixel. This is more pixelated than bilinear.<br>
				For bilinear, we take 4 nearest sample locations and find their fractional offsets (distance from those nearest locations).
				We use this to horizontally and vertically blend the textures. Which is also called interpolation. This is smoother.
				
				
				<br><br>
		- Show and compare four png screenshots
				<br><br>


				<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="1.png" width="400px"/>
				  <figcaption>Nearest sampling, 1 sample per pixel.</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="2.png" width="400px"/>
				  <figcaption>Bilinear sampling, 1 sample per pixel.</figcaption>
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center;">
				  <img src="3.png" width="400px"/>
				  <figcaption>Nearest sampling, 16 samples per pixel.</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="4.png" width="400px"/>
				  <figcaption>Bilinear sampling, 16 samples per pixel.</figcaption>
				</td>
			  </tr>
			</table>
		</div>
				
<br><br>

		- Comment on the relative differences. 
				Discuss when there will be a large difference between the two methods and why.
<br><br>
			The nearest sampling at one sample per pixel is very pixelated, with the bilinear sampling at still 1 sample per pixel
				being smoother. At 16 samples per pixel, nearest sampling is significantly more blocky, and bilinear sampling is way more smooth and 
				is a better representation of what the image looks like. The reasons for this is similar to what was detailed above,
				bilinear sampling is a weighted average of 4 texels, so it has more blended colors/textures that come out more natural 
				than nearest sampling, which is not an average and instead is just returning a single texel's color. 
				<br><br>
				
		<h2>Task 6: "Level Sampling" with mipmaps for texture mapping</h2>
				<br><br>
		- Explain level sampling in your own words and describe how you implemented it for texture mapping.<br><br>
				level sampling is just which mipmap level we choose from.<br>
				Level 0 is the full resolution texture, level 2 downsamples, level 4 downsamples again, and so on and so forth.<br>
				If we only have a small space on screen, we don't want really high resolution texture to be fitted into that small area, so we should sample a higher level. 
				We implement it for texture mapping in get_level to determine which level; this involves scaling by texture size and then using that to determine
				how large that change is, then using log2 to take into account that mipmap levels half resolution.

				<br><br>
				
 - Describe the tradeoffs between speed, memory usage, and antialiasing power between the three various techniques.<br><br>
				Level 0 is good for magnification since it's full resolution. But when displayed on smaller object, it causes jaggies and aliasing. 
				Requires more memory due to its higher quality, and also slower. 
				L_NEAREST only samples the level nearest to our computed mipmap level. Less detailed than level 0. (relatively) Faster, less memory in the same way.
				Less jaggies when shrunk. <br>
				L_LINEAR does blending between two levels, instead of only taking one like L_NEAREST, so it is the smoothest with the least jaggies when shrunk.
				Less memory, faster.<br><br>
				
				
- Using a png file you find yourself, show us four versions of the image<br><br>
				<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="L_ZERO and P_NEAREST.png" width="400px"/>
				  <figcaption>Nearest sampling, 1 sample per pixel.</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="L_ZERO and P_LINEAR.png" width="400px"/>
				  <figcaption>Bilinear sampling, 1 sample per pixel.</figcaption>
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center;">
				  <img src="L_NEAREST and P_NEAREST.png" width="400px"/>
				  <figcaption>Nearest sampling, 16 samples per pixel.</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="L_NEAREST and P_LINEAR.png" width="400px"/>
				  <figcaption>Bilinear sampling, 16 samples per pixel.</figcaption>
				</td>
			  </tr>
			</table>
		</div>


				

<!--		<h2>(Optional) Task 7: Extra Credit - Draw Something Creative!</h2>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

		<h2>Additional Notes (please remove)</h2>
		<ul>
			<li>You can also add code if you'd like as so: <code>code code code</code></li>
			<li>If you'd like to add math equations, 
				<ul>
					<li>You can write inline equations like so: \( a^2 + b^2 = c^2 \)</li>
					<li>You can write display equations like so: \[ a^2 + b^2 = c^2 \]</li>
				</ul>
			</li>
		</ul>
		</div>
	</body>
</html> -->
